<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —Ä–∞—Å—Ö–æ–¥–æ–≤ –Ω–∞ –≤–µ—á–µ—Ä–∏–Ω–∫—É</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="partycalc.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>
</head>
<body>
    <div class="page-header">
        <h1><i class="fas fa-glass-cheers"></i> –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —Ä–∞—Å—Ö–æ–¥–æ–≤ –Ω–∞ –≤–µ—á–µ—Ä–∏–Ω–∫—É</h1>
        <p class="description">–î–æ–±–∞–≤—å—Ç–µ –≥–æ—Å—Ç–µ–π –∏ –∏—Ö —Ä–∞—Å—Ö–æ–¥—ã, —á—Ç–æ–±—ã —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å, –∫—Ç–æ –∫–æ–º—É –¥–æ–ª–∂–µ–Ω –∑–∞–ø–ª–∞—Ç–∏—Ç—å</p>
    </div>

    <div class="two-column-layout">
        <div class="left-panel">
            <div id="bills-tabs" class="bills-tabs">
                <!-- Bill tabs will be rendered here -->
            </div>

            <div id="guests-container">
            <h2><i class="fas fa-users"></i> –°–ø–∏—Å–æ–∫ –≥–æ—Å—Ç–µ–π</h2>
            <p class="description">–î–æ–±–∞–≤—å—Ç–µ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ–¥–∏–Ω —Ä–∞–∑. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å—á–µ—Ç–∞ –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å, –∫—Ç–æ —É—á–∞—Å—Ç–≤—É–µ—Ç.</p>
            <div class="guest-header">
                <div class="guest-participate">‚úì</div>
                <div class="guest-name">–ò–º—è</div>
                <div class="guest-expense">
                    <div>–†–∞—Å—Ö–æ–¥—ã (‚ÇΩ)</div>
                    <div class="expense-hint">(–º–æ–∂–Ω–æ –≤–≤–æ–¥–∏—Ç—å —Ñ–æ—Ä–º—É–ª—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä: 1000+500)</div>
                </div>
                <div class="guest-plus-ones">+1</div>
                <div class="guest-action"></div>
            </div>
            <div id="guest-list">
                <!-- Guest rows will be added here dynamically -->
                <div class="empty-state" id="empty-guests">
                    <i class="fas fa-user-plus"></i>
                    <p>–î–æ–±–∞–≤—å—Ç–µ –≥–æ—Å—Ç–µ–π, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞—Å—á–µ—Ç</p>
                </div>
            </div>
            <button id="add-guest" class="btn-add"><i class="fas fa-plus"></i> –î–æ–±–∞–≤–∏—Ç—å –≥–æ—Å—Ç—è</button>
        </div>
        
        <div class="mode-selection">
            <h2><i class="fas fa-cog"></i> –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—á–µ—Ç–∞</h2>

            <div class="setting-group">
                <label class="checkbox-option main-checkbox">
                    <input type="checkbox" id="auto-optimize" checked>
                    <span><i class="fas fa-magic"></i> –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è</span>
                </label>
                <p class="setting-hint">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞–µ—Ç –ª—É—á—à—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é: –º–∏–Ω–∏–º—É–º –ø–ª–∞—Ç–µ–∂–µ–π, –∫–∞–∂–¥—ã–π –≥–æ—Å—Ç—å –ø–ª–∞—Ç–∏—Ç 1 —Ä–∞–∑ –æ–¥–Ω–æ–º—É —á–µ–ª–æ–≤–µ–∫—É</p>
            </div>

            <div id="manual-settings" style="display: none;">
                <div class="setting-group">
                    <label class="setting-label">–°—Ç—Ä–∞—Ç–µ–≥–∏—è –¥–ª—è —Å—á–µ—Ç–æ–≤:</label>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="bill-strategy" value="unified" checked>
                            <span>–û–±—â–∞—è (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="bill-strategy" value="separate">
                            <span>–†–∞–∑–¥–µ–ª—å–Ω–∞—è –ø–æ —Å—á–µ—Ç–∞–º</span>
                        </label>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="setting-label">–ú–µ—Ç–æ–¥ —Ä–∞—Å—á–µ—Ç–∞:</label>
                    <div class="radio-group">
                        <label class="radio-option">
                            <input type="radio" name="calculation-mode" value="aggregated" checked>
                            <span>–ß–µ—Ä–µ–∑ –∫–∞–∑–Ω–∞—á–µ—è</span>
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="calculation-mode" value="direct">
                            <span>–ü—Ä—è–º–æ–π —Ä–∞—Å—á–µ—Ç</span>
                        </label>
                    </div>
                </div>

                <div id="budget-keeper-container" class="setting-group">
                    <label class="setting-label" for="budget-keeper">–ö–∞–∑–Ω–∞—á–µ–π:</label>
                    <select id="budget-keeper">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ—Å—Ç—è</option>
                    </select>
                </div>
            </div>

            <div class="setting-group">
                <p class="setting-hint"><i class="fas fa-info-circle"></i> <strong>+1 —Ä–µ–∂–∏–º:</strong> –ï—Å–ª–∏ –≥–æ—Å—Ç—å –ø—Ä–∏–≤–æ–¥–∏—Ç —Å —Å–æ–±–æ–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ª—é–¥–µ–π, —É–∫–∞–∂–∏—Ç–µ –∏—Ö –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ. –û—Å–Ω–æ–≤–Ω–æ–π –≥–æ—Å—Ç—å –ø–ª–∞—Ç–∏—Ç –∑–∞ –≤—Å–µ—Ö —Å–≤–æ–∏—Ö +1.</p>
            </div>
        </div>

        <div class="action-buttons">
            <button id="calculate"><i class="fas fa-calculator"></i> –†–∞—Å—Å—á–∏—Ç–∞—Ç—å</button>
            <button id="clear-storage" class="btn-danger"><i class="fas fa-trash"></i> –û—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
        </div>
        </div>

        <div class="right-panel">
            <div id="results" class="results-container">
                <div class="empty-results">
                    <i class="fas fa-chart-line"></i>
                    <p>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á–µ—Ç–∞ –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å</p>
                    <p class="hint">–î–æ–±–∞–≤—å—Ç–µ –≥–æ—Å—Ç–µ–π –∏ –Ω–∞–∂–º–∏—Ç–µ "–†–∞—Å—Å—á–∏—Ç–∞—Ç—å"</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Data model
        let partyData = {
            guests: [], // Shared guest list
            bills: [
                {
                    id: 'bill-0',
                    name: '–û—Å–Ω–æ–≤–Ω–æ–π —Å—á–µ—Ç',
                    participants: [], // indices of guests
                    expenses: {} // guest index: expense amount
                }
            ],
            activeBillId: 'bill-0',
            autoOptimize: true,
            billStrategy: 'unified', // unified or separate
            mode: 'aggregated', // direct or aggregated
            budgetKeeper: null
        };
        
        // DOM elements
        const guestListEl = document.getElementById('guest-list');
        const emptyGuestsEl = document.getElementById('empty-guests');
        const addGuestBtn = document.getElementById('add-guest');
        const calculateBtn = document.getElementById('calculate');
        const clearStorageBtn = document.getElementById('clear-storage');
        const resultsEl = document.getElementById('results');
        const autoOptimizeCheckbox = document.getElementById('auto-optimize');
        const manualSettingsDiv = document.getElementById('manual-settings');
        const billStrategyRadios = document.getElementsByName('bill-strategy');
        const modeRadios = document.getElementsByName('calculation-mode');
        const budgetKeeperContainer = document.getElementById('budget-keeper-container');
        const budgetKeeperSelect = document.getElementById('budget-keeper');
        
        // Migrate old data format to new multi-bill format
        function migrateOldData(data) {
            // Check if data is in old format (has expenses in guests)
            if (data.guests && data.guests.length > 0 && data.guests[0].hasOwnProperty('expenses')) {
                const migratedData = {
                    guests: data.guests.map(g => ({
                        name: g.name,
                        plusOnes: g.plusOnes || 0
                    })),
                    bills: [{
                        id: 'bill-0',
                        name: '–û—Å–Ω–æ–≤–Ω–æ–π —Å—á–µ—Ç',
                        participants: data.guests.map((_, i) => i),
                        expenses: data.guests.reduce((acc, g, i) => {
                            acc[i] = {
                                amount: g.expenses || 0,
                                expression: g.expenseExpression || null
                            };
                            return acc;
                        }, {})
                    }],
                    activeBillId: 'bill-0',
                    autoOptimize: true,
                    billStrategy: 'unified',
                    mode: 'aggregated',
                    budgetKeeper: null
                };
                return migratedData;
            }
            return data;
        }

        // Load data from localStorage
        function loadFromStorage() {
            const savedData = localStorage.getItem('partyCalcData');
            if (savedData) {
                try {
                    let data = JSON.parse(savedData);
                    data = migrateOldData(data);
                    partyData = data;

                    renderBillTabs();
                    renderGuestList();
                    updateBudgetKeeperOptions();
                    
                    // Set the correct mode
                    for (const radio of modeRadios) {
                        if (radio.value === partyData.mode) {
                            radio.checked = true;
                            break;
                        }
                    }
                    
                    // Show/hide budget keeper selection
                    budgetKeeperContainer.style.display = partyData.mode === 'aggregated' ? 'block' : 'none';
                    
                    // Set the budget keeper if in aggregated mode
                    if (partyData.mode === 'aggregated' && partyData.budgetKeeper !== null) {
                        budgetKeeperSelect.value = partyData.budgetKeeper;
                    }

                    // Set auto-optimize checkbox and show/hide manual settings
                    if (autoOptimizeCheckbox) {
                        autoOptimizeCheckbox.checked = partyData.autoOptimize !== false;
                        manualSettingsDiv.style.display = partyData.autoOptimize ? 'none' : 'block';
                    }

                    // Set bill strategy
                    for (const radio of billStrategyRadios) {
                        if (radio.value === (partyData.billStrategy || 'unified')) {
                            radio.checked = true;
                            break;
                        }
                    }

                    // Update budget keeper visibility
                    updateBudgetKeeperVisibility();
                } catch (e) {
                    console.error('Error loading data from localStorage:', e);
                    clearStorage();
                }
            }
        }
        
        // Save data to localStorage
        function saveToStorage() {
            localStorage.setItem('partyCalcData', JSON.stringify(partyData));
        }
        
        // Auto-recalculation with debounce
        let recalculateTimeout = null;

        function scheduleRecalculation() {
            clearTimeout(recalculateTimeout);
            recalculateTimeout = setTimeout(() => {
                autoCalculate();
            }, 500); // 500ms debounce
        }

        function autoCalculate() {
            // Validate data before calculating
            if (partyData.guests.length < 2) {
                showPlaceholder('–î–æ–±–∞–≤—å—Ç–µ –º–∏–Ω–∏–º—É–º 2 –≥–æ—Å—Ç–µ–π –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞');
                return;
            }

            const emptyNames = partyData.guests.some(guest => !guest.name.trim());
            if (emptyNames) {
                showPlaceholder('–£–∫–∞–∂–∏—Ç–µ –∏–º–µ–Ω–∞ –≤—Å–µ—Ö –≥–æ—Å—Ç–µ–π');
                return;
            }

            // Only check for treasurer in manual mode
            if (!partyData.autoOptimize && partyData.mode === 'aggregated' && partyData.budgetKeeper === null) {
                showPlaceholder('–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∑–Ω–∞—á–µ—è –¥–ª—è —Ä–µ–∂–∏–º–∞ "–ß–µ—Ä–µ–∑ –∫–∞–∑–Ω–∞—á–µ—è"');
                return;
            }

            // All validations passed, calculate
            calculatePayments();
        }

        function showPlaceholder(message) {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = `
                <div class="empty-results">
                    <i class="fas fa-info-circle"></i>
                    <p>${message}</p>
                </div>
            `;
        }

        // Clear localStorage
        function clearStorage() {
            localStorage.removeItem('partyCalcData');
            partyData = {
                guests: [],
                bills: [{
                    id: 'bill-0',
                    name: '–û—Å–Ω–æ–≤–Ω–æ–π —Å—á–µ—Ç',
                    participants: [],
                    expenses: {}
                }],
                activeBillId: 'bill-0',
                autoOptimize: true,
                billStrategy: 'unified',
                mode: 'aggregated',
                budgetKeeper: null
            };
            renderBillTabs();
            renderGuestList();
            updateBudgetKeeperOptions();
            showPlaceholder('–î–æ–±–∞–≤—å—Ç–µ –≥–æ—Å—Ç–µ–π –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã');

            // Reset UI
            autoOptimizeCheckbox.checked = true;
            manualSettingsDiv.style.display = 'none';
            modeRadios[0].checked = true;
            billStrategyRadios[0].checked = true;
        }

        // Update budget keeper visibility based on mode
        function updateBudgetKeeperVisibility() {
            const showKeeper = !partyData.autoOptimize && partyData.mode === 'aggregated';
            budgetKeeperContainer.style.display = showKeeper ? 'block' : 'none';
        }
        
        // Get active bill
        function getActiveBill() {
            return partyData.bills.find(b => b.id === partyData.activeBillId) || partyData.bills[0];
        }

        // Render bill tabs
        function renderBillTabs() {
            const tabsContainer = document.getElementById('bills-tabs');
            tabsContainer.innerHTML = '';

            partyData.bills.forEach((bill, index) => {
                const tab = document.createElement('button');
                tab.className = 'bill-tab' + (bill.id === partyData.activeBillId ? ' active' : '');

                const nameSpan = document.createElement('span');
                nameSpan.textContent = bill.name;
                nameSpan.className = 'bill-tab-name';
                tab.appendChild(nameSpan);

                // Add edit and close buttons
                const actionsWrapper = document.createElement('span');
                actionsWrapper.className = 'bill-tab-actions';

                const editBtn = document.createElement('span');
                editBtn.className = 'bill-tab-edit';
                editBtn.innerHTML = '<i class="fas fa-pen"></i>';
                editBtn.title = '–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    renameBill(bill.id);
                };
                actionsWrapper.appendChild(editBtn);

                // Add close button if more than one bill
                if (partyData.bills.length > 1) {
                    const closeBtn = document.createElement('span');
                    closeBtn.className = 'bill-tab-close';
                    closeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    closeBtn.title = '–£–¥–∞–ª–∏—Ç—å —Å—á–µ—Ç';
                    closeBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeBill(bill.id);
                    };
                    actionsWrapper.appendChild(closeBtn);
                }

                tab.appendChild(actionsWrapper);
                tab.onclick = () => switchToBill(bill.id);

                tabsContainer.appendChild(tab);
            });

            // Add "+" button to create new bill
            const addBtn = document.createElement('button');
            addBtn.className = 'add-bill-btn';
            addBtn.innerHTML = '<i class="fas fa-plus"></i> –°—á–µ—Ç';
            addBtn.onclick = addBill;
            tabsContainer.appendChild(addBtn);
        }

        // Rename a bill with prompt
        function renameBill(billId) {
            const bill = partyData.bills.find(b => b.id === billId);
            if (!bill) return;

            const newName = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—á–µ—Ç–∞:', bill.name);
            if (newName && newName.trim() && newName.trim() !== bill.name) {
                bill.name = newName.trim();
                saveToStorage();
                renderBillTabs();
                scheduleRecalculation();
            }
        }

        // Switch to a different bill
        function switchToBill(billId) {
            partyData.activeBillId = billId;
            renderBillTabs();
            renderGuestList();
            saveToStorage();
            scheduleRecalculation();
        }

        // Add a new bill
        function addBill() {
            const billNumber = partyData.bills.length + 1;
            const newBill = {
                id: `bill-${Date.now()}`,
                name: `–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å—á–µ—Ç ${billNumber - 1}`,
                participants: partyData.guests.map((_, i) => i), // All guests by default
                expenses: {}
            };
            partyData.bills.push(newBill);
            partyData.activeBillId = newBill.id;
            renderBillTabs();
            renderGuestList();
            saveToStorage();
            scheduleRecalculation();
        }

        // Remove a bill
        function removeBill(billId) {
            if (partyData.bills.length <= 1) {
                alert('–î–æ–ª–∂–µ–Ω –æ—Å—Ç–∞—Ç—å—Å—è —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å—á–µ—Ç');
                return;
            }

            if (confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç —Å—á–µ—Ç?')) {
                partyData.bills = partyData.bills.filter(b => b.id !== billId);

                // Switch to first bill if we deleted the active one
                if (partyData.activeBillId === billId) {
                    partyData.activeBillId = partyData.bills[0].id;
                }

                renderBillTabs();
                renderGuestList();
                saveToStorage();
                scheduleRecalculation();
            }
        }

        // Add a new guest
        function addGuest() {
            const guestIndex = partyData.guests.length;
            partyData.guests.push({
                name: '',
                plusOnes: 0
            });

            // Add guest to all bills as participant by default
            partyData.bills.forEach(bill => {
                bill.participants.push(guestIndex);
                bill.expenses[guestIndex] = { amount: 0, expression: null };
            });

            renderBillTabs();
            renderGuestList();
            updateBudgetKeeperOptions();
            saveToStorage();
        }
        
        // Remove a guest
        function removeGuest(index) {
            partyData.guests.splice(index, 1);

            // Remove from all bills and adjust indices
            partyData.bills.forEach(bill => {
                // Remove from participants
                bill.participants = bill.participants
                    .filter(i => i !== index)
                    .map(i => i > index ? i - 1 : i);

                // Remove expenses and adjust keys
                const newExpenses = {};
                Object.keys(bill.expenses).forEach(key => {
                    const idx = parseInt(key);
                    if (idx < index) {
                        newExpenses[idx] = bill.expenses[key];
                    } else if (idx > index) {
                        newExpenses[idx - 1] = bill.expenses[key];
                    }
                });
                bill.expenses = newExpenses;
            });

            // If the budget keeper was removed, reset it
            if (partyData.budgetKeeper === index) {
                partyData.budgetKeeper = null;
            }
            // If the budget keeper was after the removed guest, adjust the index
            else if (partyData.budgetKeeper > index) {
                partyData.budgetKeeper--;
            }

            renderBillTabs();
            renderGuestList();
            updateBudgetKeeperOptions();
            saveToStorage();
        }
        
        // Update guest name
        function updateGuestName(index, name) {
            partyData.guests[index].name = name;
            updateBudgetKeeperOptions();
            saveToStorage();
            scheduleRecalculation();
        }
        
        // Safe expression evaluation function using math.js
        function evaluateExpression(expression) {
            try {
                // Use math.js for safe evaluation (no code execution)
                const result = math.evaluate(expression);

                // Ensure result is a number
                if (typeof result !== 'number' || !isFinite(result)) {
                    throw new Error('Result is not a valid number');
                }

                console.log('Calculated expression:', expression, '=', result);
                return result;
            } catch (e) {
                console.error('Error in expression calculation:', expression, e);
                throw e;
            }
        }
        
        // Update guest expenses for active bill
        function updateGuestExpenses(index, expenses) {
            const activeBill = getActiveBill();
            if (!activeBill.expenses[index]) {
                activeBill.expenses[index] = { amount: 0, expression: null };
            }

            // Check if the input contains arithmetic operators
            if (/[\+\-\*\/]/.test(expenses)) {
                try {
                    // Calculate the result safely
                    const result = evaluateExpression(expenses);
                    const numericResult = parseFloat(result);

                    if (isNaN(numericResult)) {
                        throw new Error('Result is not a number');
                    }

                    activeBill.expenses[index] = {
                        amount: numericResult,
                        expression: expenses
                    };

                    // Update the UI to show the result
                    const guestRow = document.querySelectorAll('.guest-row')[index];
                    if (guestRow) {
                        const expenseContainer = guestRow.querySelector('.expense-container');
                        if (expenseContainer) {
                            const inputWrapper = expenseContainer.querySelector('.expense-input-wrapper');
                            if (inputWrapper) {
                                let resultDisplay = inputWrapper.querySelector('.expense-result');
                                if (!resultDisplay) {
                                    resultDisplay = document.createElement('span');
                                    resultDisplay.className = 'expense-result';
                                    inputWrapper.appendChild(resultDisplay);
                                }
                                resultDisplay.textContent = `= ${numericResult} ‚ÇΩ`;
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error calculating expression:', e);
                    // If calculation fails, just use the input as is
                    activeBill.expenses[index] = {
                        amount: parseFloat(expenses) || 0,
                        expression: null
                    };
                }
            } else {
                // Regular number input
                activeBill.expenses[index] = {
                    amount: parseFloat(expenses) || 0,
                    expression: null
                };
            }
            saveToStorage();
            scheduleRecalculation();
        }

        // Toggle guest participation in active bill
        function toggleGuestParticipation(index, participating) {
            const activeBill = getActiveBill();
            if (participating) {
                if (!activeBill.participants.includes(index)) {
                    activeBill.participants.push(index);
                }
                if (!activeBill.expenses[index]) {
                    activeBill.expenses[index] = { amount: 0, expression: null };
                }
            } else {
                activeBill.participants = activeBill.participants.filter(i => i !== index);
            }
            saveToStorage();
            scheduleRecalculation();
        }

        // Update guest plus ones
        function updateGuestPlusOnes(index, plusOnes) {
            partyData.guests[index].plusOnes = parseInt(plusOnes) || 0;
            saveToStorage();
            scheduleRecalculation();
        }
        
        // Render the guest list
        function renderGuestList() {
            const activeBill = getActiveBill();

            // Clear the guest list
            while (guestListEl.firstChild) {
                guestListEl.removeChild(guestListEl.firstChild);
            }

            // Show empty state if no guests
            if (partyData.guests.length === 0) {
                guestListEl.appendChild(emptyGuestsEl);
                return;
            }

            // Hide empty state
            if (emptyGuestsEl.parentNode === guestListEl) {
                guestListEl.removeChild(emptyGuestsEl);
            }

            // Add each guest
            partyData.guests.forEach((guest, index) => {
                const guestRow = document.createElement('div');
                guestRow.className = 'guest-row';

                // Participation checkbox
                const participateCheckbox = document.createElement('input');
                participateCheckbox.type = 'checkbox';
                participateCheckbox.className = 'guest-participate';
                participateCheckbox.checked = activeBill.participants.includes(index);
                participateCheckbox.title = '–£—á–∞—Å—Ç–≤—É–µ—Ç –≤ —ç—Ç–æ–º —Å—á–µ—Ç–µ';
                participateCheckbox.addEventListener('change', (e) => {
                    toggleGuestParticipation(index, e.target.checked);
                });

                const participateDiv = document.createElement('div');
                participateDiv.className = 'guest-participate';
                participateDiv.appendChild(participateCheckbox);

                // Name input
                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'guest-name';
                nameInput.placeholder = '–ò–º—è –≥–æ—Å—Ç—è';
                nameInput.value = guest.name;
                nameInput.addEventListener('input', (e) => {
                    updateGuestName(index, e.target.value);
                });

                // Expense input
                const expenseInput = document.createElement('input');
                expenseInput.type = 'text';
                expenseInput.className = 'guest-expense';
                expenseInput.placeholder = '–ß–∏—Å–ª–æ –∏–ª–∏ —Ñ–æ—Ä–º—É–ª–∞';
                expenseInput.disabled = !activeBill.participants.includes(index);

                // Get expense from active bill
                const billExpense = activeBill.expenses[index] || { amount: 0, expression: null };

                if (billExpense.expression) {
                    expenseInput.value = billExpense.expression;
                } else if (billExpense.amount > 0) {
                    expenseInput.value = billExpense.amount;
                } else {
                    expenseInput.value = '';
                }

                expenseInput.title = '–ú–æ–∂–Ω–æ –≤–≤–æ–¥–∏—Ç—å —á–∏—Å–ª–∞ –∏–ª–∏ —Ñ–æ—Ä–º—É–ª—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1000+500)';

                // Create a container for the expense input and result display
                const expenseContainer = document.createElement('div');
                expenseContainer.className = 'expense-container';

                // Create a wrapper for input and result to keep them on the same line
                const inputWrapper = document.createElement('div');
                inputWrapper.className = 'expense-input-wrapper';
                inputWrapper.appendChild(expenseInput);

                // Add result display if there's an expression
                if (billExpense.expression) {
                    const resultDisplay = document.createElement('span');
                    resultDisplay.className = 'expense-result';
                    resultDisplay.textContent = `= ${billExpense.amount} ‚ÇΩ`;
                    inputWrapper.appendChild(resultDisplay);
                }

                expenseContainer.appendChild(inputWrapper);

                expenseInput.addEventListener('input', (e) => {
                    updateGuestExpenses(index, e.target.value);
                });

                // Plus ones input
                const plusOnesInput = document.createElement('input');
                plusOnesInput.type = 'number';
                plusOnesInput.className = 'guest-plus-ones';
                plusOnesInput.placeholder = '+1';
                plusOnesInput.min = '0';
                plusOnesInput.value = guest.plusOnes || 0;
                plusOnesInput.title = '–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –≥–æ—Å—Ç–µ–π (+1)';
                plusOnesInput.addEventListener('input', (e) => {
                    updateGuestPlusOnes(index, e.target.value);
                });

                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'btn-remove guest-action';
                removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                removeBtn.addEventListener('click', () => {
                    removeGuest(index);
                });

                guestRow.appendChild(participateDiv);
                guestRow.appendChild(nameInput);
                guestRow.appendChild(expenseContainer);
                guestRow.appendChild(plusOnesInput);
                guestRow.appendChild(removeBtn);

                guestListEl.appendChild(guestRow);
            });
        }
        
        // Update budget keeper options
        function updateBudgetKeeperOptions() {
            // Clear the select options
            budgetKeeperSelect.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ—Å—Ç—è</option>';
            
            // Add each guest as an option
            partyData.guests.forEach((guest, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = guest.name || `–ì–æ—Å—Ç—å ${index + 1}`;
                budgetKeeperSelect.appendChild(option);
            });
            
            // Set the selected option
            if (partyData.budgetKeeper !== null) {
                budgetKeeperSelect.value = partyData.budgetKeeper;
            }
        }
        
        // Auto-optimize: find best treasurer (who spent the most across all bills)
        function findOptimalTreasurer(billsData) {
            const totalExpenses = {};
            billsData.forEach(bd => {
                bd.participants.forEach(p => {
                    if (!totalExpenses[p.index]) {
                        totalExpenses[p.index] = 0;
                    }
                    totalExpenses[p.index] += p.expense;
                });
            });

            let maxExpense = 0;
            let treasurerIndex = 0;
            Object.entries(totalExpenses).forEach(([idx, expense]) => {
                if (expense > maxExpense) {
                    maxExpense = expense;
                    treasurerIndex = parseInt(idx);
                }
            });

            return treasurerIndex;
        }

        // Calculate payments for all bills
        function calculatePayments() {
            // Check if there are at least 2 guests
            if (partyData.guests.length < 2) {
                alert('–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –¥–≤—É—Ö –≥–æ—Å—Ç–µ–π –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞');
                return;
            }

            // Check if all guests have names
            const emptyNames = partyData.guests.some(guest => !guest.name.trim());
            if (emptyNames) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∏–º–µ–Ω–∞ –≤—Å–µ—Ö –≥–æ—Å—Ç–µ–π');
                return;
            }

            // Prepare bills data
            const billsData = [];
            partyData.bills.forEach(bill => {
                const participants = bill.participants.map(idx => ({
                    index: idx,
                    guest: partyData.guests[idx],
                    expense: (bill.expenses[idx] || { amount: 0 }).amount
                }));

                if (participants.length < 2) return;

                const totalExpenses = participants.reduce((sum, p) => sum + p.expense, 0);
                const totalPeople = participants.reduce((sum, p) => sum + 1 + (p.guest.plusOnes || 0), 0);
                const perPersonShare = totalExpenses / totalPeople;

                billsData.push({
                    bill,
                    participants,
                    totalExpenses,
                    totalPeople,
                    perPersonShare
                });
            });

            if (billsData.length === 0) {
                showPlaceholder('–î–æ–±–∞–≤—å—Ç–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –≤ —Å—á–µ—Ç–∞');
                return;
            }

            let finalPayments = [];
            let usedTreasurer = null;

            if (partyData.autoOptimize) {
                // AUTO-OPTIMIZATION MODE
                // Strategy: unified treasurer approach for simplicity
                // Find who spent the most - they become treasurer
                const treasurerIndex = findOptimalTreasurer(billsData);
                usedTreasurer = treasurerIndex;

                // Calculate consolidated balances for all guests across all bills
                const guestBalances = {};
                partyData.guests.forEach((_, idx) => {
                    guestBalances[idx] = 0;
                });

                billsData.forEach(bd => {
                    bd.participants.forEach(p => {
                        const share = bd.perPersonShare * (1 + (p.guest.plusOnes || 0));
                        guestBalances[p.index] += p.expense - share;
                    });
                });

                // Create payments: everyone pays to or receives from treasurer
                Object.entries(guestBalances).forEach(([idx, balance]) => {
                    const guestIdx = parseInt(idx);
                    if (guestIdx === treasurerIndex) return;

                    if (balance < -0.01) {
                        // Guest owes money
                        finalPayments.push({
                            from: guestIdx,
                            to: treasurerIndex,
                            amount: Math.round(-balance * 100) / 100
                        });
                    } else if (balance > 0.01) {
                        // Treasurer owes money to guest
                        finalPayments.push({
                            from: treasurerIndex,
                            to: guestIdx,
                            amount: Math.round(balance * 100) / 100
                        });
                    }
                });
            } else {
                // MANUAL MODE
                if (partyData.mode === 'aggregated' && partyData.budgetKeeper === null) {
                    alert('–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∑–Ω–∞—á–µ—è –¥–ª—è —Ä–µ–∂–∏–º–∞ "–ß–µ—Ä–µ–∑ –∫–∞–∑–Ω–∞—á–µ—è"');
                    return;
                }

                usedTreasurer = partyData.budgetKeeper;

                if (partyData.billStrategy === 'unified') {
                    // Unified strategy: same approach across all bills
                    const guestBalances = {};
                    partyData.guests.forEach((_, idx) => {
                        guestBalances[idx] = 0;
                    });

                    billsData.forEach(bd => {
                        bd.participants.forEach(p => {
                            const share = bd.perPersonShare * (1 + (p.guest.plusOnes || 0));
                            guestBalances[p.index] += p.expense - share;
                        });
                    });

                    if (partyData.mode === 'aggregated') {
                        // Treasurer mode
                        const treasurerIdx = parseInt(partyData.budgetKeeper);
                        Object.entries(guestBalances).forEach(([idx, balance]) => {
                            const guestIdx = parseInt(idx);
                            if (guestIdx === treasurerIdx) return;

                            if (balance < -0.01) {
                                finalPayments.push({
                                    from: guestIdx,
                                    to: treasurerIdx,
                                    amount: Math.round(-balance * 100) / 100
                                });
                            } else if (balance > 0.01) {
                                finalPayments.push({
                                    from: treasurerIdx,
                                    to: guestIdx,
                                    amount: Math.round(balance * 100) / 100
                                });
                            }
                        });
                    } else {
                        // Direct mode - optimize transactions
                        const balances = Object.entries(guestBalances).map(([idx, balance]) => ({
                            index: parseInt(idx),
                            balance
                        }));
                        finalPayments = minimizeTransactionsFromBalances(balances);
                    }
                } else {
                    // Separate strategy: calculate each bill independently
                    let allPayments = [];
                    billsData.forEach(bd => {
                        const billGuests = bd.participants.map(p => ({
                            ...p.guest,
                            index: p.index,
                            expenses: p.expense
                        }));
                        const billPayments = minimizeTransactionsBill(billGuests, bd.perPersonShare);
                        allPayments.push(...billPayments);
                    });
                    finalPayments = consolidatePayments(allPayments);
                }
            }

            // Filter out small payments
            finalPayments = finalPayments.filter(p => p.amount >= 1);

            // Calculate totals
            const overallTotalExpenses = billsData.reduce((sum, bd) => sum + bd.totalExpenses, 0);
            const overallTotalPeople = partyData.guests.reduce((sum, g) => sum + 1 + (g.plusOnes || 0), 0);

            // Display results
            displayResults(billsData, finalPayments, overallTotalExpenses, overallTotalPeople, usedTreasurer);
        }

        // Helper functions for multi-bill payments
        function minimizeTransactionsBill(guests, perPersonShare) {
            const balances = guests.map(guest => {
                const totalShare = perPersonShare * (1 + (guest.plusOnes || 0));
                return {
                    index: guest.index,
                    balance: guest.expenses - totalShare
                };
            });

            const debtors = balances.filter(b => b.balance < -0.01).map(b => ({ ...b, balance: -b.balance })).sort((a, b) => b.balance - a.balance);
            const creditors = balances.filter(b => b.balance > 0.01).sort((a, b) => b.balance - a.balance);

            const payments = [];
            let i = 0, j = 0;
            while (i < debtors.length && j < creditors.length) {
                const payment = Math.min(debtors[i].balance, creditors[j].balance);
                if (payment > 0.01) {
                    payments.push({
                        from: debtors[i].index,
                        to: creditors[j].index,
                        amount: Math.round(payment * 100) / 100
                    });
                }
                debtors[i].balance -= payment;
                creditors[j].balance -= payment;
                if (debtors[i].balance < 0.01) i++;
                if (creditors[j].balance < 0.01) j++;
            }
            return payments;
        }

        function calculateDirectPayments(guests, perPersonShare) {
            // Same logic as minimizeTransactionsBill for now
            return minimizeTransactionsBill(guests, perPersonShare);
        }

        function consolidatePayments(payments) {
            const consolidated = {};
            payments.forEach(p => {
                const key = `${p.from}->${p.to}`;
                if (!consolidated[key]) {
                    consolidated[key] = { from: p.from, to: p.to, amount: 0 };
                }
                consolidated[key].amount += p.amount;
            });
            return Object.values(consolidated).map(p => ({
                ...p,
                amount: Math.round(p.amount * 100) / 100
            }));
        }

        // Minimize transactions from pre-calculated balances
        function minimizeTransactionsFromBalances(balances) {
            const debtors = balances
                .filter(b => b.balance < -0.01)
                .map(b => ({ ...b, balance: -b.balance }))
                .sort((a, b) => b.balance - a.balance);

            const creditors = balances
                .filter(b => b.balance > 0.01)
                .sort((a, b) => b.balance - a.balance);

            const payments = [];
            let i = 0, j = 0;

            while (i < debtors.length && j < creditors.length) {
                const payment = Math.min(debtors[i].balance, creditors[j].balance);
                if (payment > 0.01) {
                    payments.push({
                        from: debtors[i].index,
                        to: creditors[j].index,
                        amount: Math.round(payment * 100) / 100
                    });
                }
                debtors[i].balance -= payment;
                creditors[j].balance -= payment;
                if (debtors[i].balance < 0.01) i++;
                if (creditors[j].balance < 0.01) j++;
            }

            return payments;
        }

        // Optimized payment algorithm - minimizes number of transactions
        function minimizeTransactions(guests, perPersonShare) {
            // Calculate balances for each guest (positive = should receive, negative = should pay)
            const balances = guests.map((guest, index) => {
                const totalShare = perPersonShare * (1 + (guest.plusOnes || 0));
                return {
                    index,
                    name: guest.name,
                    balance: guest.expenses - totalShare,
                    plusOnes: guest.plusOnes || 0
                };
            });

            // Separate debtors and creditors
            const debtors = balances
                .filter(b => b.balance < -0.01)
                .map(b => ({ ...b, balance: -b.balance }))
                .sort((a, b) => b.balance - a.balance);

            const creditors = balances
                .filter(b => b.balance > 0.01)
                .sort((a, b) => b.balance - a.balance);

            const payments = [];

            // Greedy algorithm: match largest debts with largest credits
            let i = 0, j = 0;
            while (i < debtors.length && j < creditors.length) {
                const debtor = debtors[i];
                const creditor = creditors[j];

                const payment = Math.min(debtor.balance, creditor.balance);

                if (payment > 0.01) {
                    payments.push({
                        from: debtor.index,
                        to: creditor.index,
                        amount: Math.round(payment * 100) / 100
                    });
                }

                debtor.balance -= payment;
                creditor.balance -= payment;

                if (debtor.balance < 0.01) i++;
                if (creditor.balance < 0.01) j++;
            }

            return payments;
        }

        // Display calculation results (multi-bill support)
        function displayResults(billsData, payments, totalExpenses, totalPeople, treasurerIndex) {
            let html = `
                <h2><i class="fas fa-receipt"></i> –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á–µ—Ç–∞</h2>
                <div class="summary-card">
                    <p>–û–±—â–∏–µ —Ä–∞—Å—Ö–æ–¥—ã: <strong>${totalExpenses.toLocaleString('ru-RU')} ‚ÇΩ</strong></p>
                    <p>–í—Å–µ–≥–æ –≥–æ—Å—Ç–µ–π (–≤–∫–ª—é—á–∞—è +1): <strong>${totalPeople}</strong></p>
            `;

            if (treasurerIndex !== null && treasurerIndex !== undefined) {
                const treasurer = partyData.guests[treasurerIndex];
                if (treasurer) {
                    html += `<p><i class="fas fa-user-tie"></i> –ö–∞–∑–Ω–∞—á–µ–π: <strong>${treasurer.name}</strong></p>`;
                }
            }

            html += `</div>`;

            // Show each bill's summary if more than one bill
            if (billsData.length > 1) {
                html += `<h3><i class="fas fa-file-invoice"></i> –î–µ—Ç–∞–ª–∏ –ø–æ —Å—á–µ—Ç–∞–º:</h3>`;
                billsData.forEach(bd => {
                    html += `
                        <div class="bill-summary">
                            <strong>${bd.bill.name}:</strong> ${bd.totalExpenses.toLocaleString('ru-RU')} ‚ÇΩ
                            (${bd.totalPeople} —á–µ–ª., ${bd.perPersonShare.toLocaleString('ru-RU', {minimumFractionDigits: 2, maximumFractionDigits: 2})} ‚ÇΩ/—á–µ–ª.)
                        </div>
                    `;
                });
            }

            if (payments.length === 0) {
                html += `
                    <div class="summary-card">
                        <p><i class="fas fa-check-circle"></i> –í—Å–µ –≥–æ—Å—Ç–∏ –ø–æ—Ç—Ä–∞—Ç–∏–ª–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —Å—É–º–º—É. –ù–∏–∫–∞–∫–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.</p>
                    </div>
                `;
            } else {
                html += `
                    <h3><i class="fas fa-exchange-alt"></i> –ò—Ç–æ–≥–æ–≤—ã–µ –ø–ª–∞—Ç–µ–∂–∏:</h3>
                    <div class="transactions-info">
                        <p><i class="fas fa-info-circle"></i> –í—Å–µ–≥–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: <strong>${payments.length}</strong></p>
                    </div>
                `;

                payments.forEach(payment => {
                    const fromGuest = partyData.guests[payment.from];
                    const toGuest = partyData.guests[payment.to];

                    const fromGuestDisplay = fromGuest.plusOnes > 0
                        ? `${fromGuest.name} (+${fromGuest.plusOnes})`
                        : fromGuest.name;

                    const toGuestDisplay = toGuest.plusOnes > 0
                        ? `${toGuest.name} (+${toGuest.plusOnes})`
                        : toGuest.name;

                    html += `
                        <div class="payment-instruction">
                            <span>${fromGuestDisplay}</span>
                            <i class="fas fa-arrow-right" style="color: var(--primary-color); font-size: 1.2em; margin: 0 10px;"></i>
                            <span>${toGuestDisplay}</span>
                            <i class="fas fa-ruble-sign"></i>
                            <span class="payment-amount">${payment.amount.toLocaleString('ru-RU', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                        </div>
                    `;
                });
            }

            html += `
                <div class="export-section">
                    <button id="export-messenger" class="btn-export">
                        <i class="fas fa-share-alt"></i> –≠–∫—Å–ø–æ—Ä—Ç –¥–ª—è –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä–∞
                    </button>
                </div>
            `;

            resultsEl.innerHTML = html;

            // Add export button handler
            const exportBtn = document.getElementById('export-messenger');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => exportForMessenger(billsData, payments));
            }
        }

        // Export for messenger (multi-bill support)
        function exportForMessenger(billsData, payments) {
            let text = 'üéâ –†–∞—Å—á–µ—Ç —Ä–∞—Å—Ö–æ–¥–æ–≤ –Ω–∞ –≤–µ—á–µ—Ä–∏–Ω–∫—É\n\n';

            // Export each bill
            billsData.forEach((bd, idx) => {
                text += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
                text += `üìã ${bd.bill.name}\n\n`;

                // Participants for this bill
                const billParticipants = bd.participants.map(p => {
                    return p.guest.plusOnes > 0 ? `${p.guest.name} (+${p.guest.plusOnes})` : p.guest.name;
                });
                text += `üë• –£—á–∞—Å—Ç–Ω–∏–∫–∏: ${billParticipants.join(', ')}\n\n`;

                // Expenses for this bill
                text += 'üí∞ –†–∞—Å—Ö–æ–¥—ã:\n';
                bd.participants.forEach(p => {
                    const guestName = p.guest.plusOnes > 0 ? `${p.guest.name} (+${p.guest.plusOnes})` : p.guest.name;
                    const expense = bd.bill.expenses[p.index];
                    if (expense && expense.expression) {
                        text += `‚Ä¢ ${guestName}: ${expense.expression} = ${expense.amount.toLocaleString('ru-RU')} ‚ÇΩ\n`;
                    } else {
                        text += `‚Ä¢ ${guestName}: ${expense ? expense.amount.toLocaleString('ru-RU') : 0} ‚ÇΩ\n`;
                    }
                });

                // Summary for this bill
                text += `\nüìà –ò—Ç–æ–≥–æ: ${bd.totalExpenses.toLocaleString('ru-RU')} ‚ÇΩ\n`;
                text += `üíµ –î–æ–ª—è –Ω–∞ —á–µ–ª–æ–≤–µ–∫–∞: ${bd.perPersonShare.toLocaleString('ru-RU', {minimumFractionDigits: 2, maximumFractionDigits: 2})} ‚ÇΩ\n\n`;
            });

            // Final consolidated payments
            if (payments.length === 0) {
                text += '‚úÖ –í—Å–µ –≥–æ—Å—Ç–∏ –ø–æ—Ç—Ä–∞—Ç–∏–ª–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—É—é —Å—É–º–º—É.\n–ù–∏–∫–∞–∫–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.\n';
            } else {
                text += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
                text += 'üí∏ –ò–¢–û–ì–û–í–´–ï –ü–õ–ê–¢–ï–ñ–ò:\n\n';

                payments.forEach(payment => {
                    const fromGuest = partyData.guests[payment.from];
                    const toGuest = partyData.guests[payment.to];

                    const fromGuestDisplay = fromGuest.plusOnes > 0
                        ? `${fromGuest.name} (+${fromGuest.plusOnes})`
                        : fromGuest.name;

                    const toGuestDisplay = toGuest.plusOnes > 0
                        ? `${toGuest.name} (+${toGuest.plusOnes})`
                        : toGuest.name;

                    text += `${fromGuestDisplay} ‚Üí ${toGuestDisplay}: ${payment.amount.toLocaleString('ru-RU', {minimumFractionDigits: 2, maximumFractionDigits: 2})} ‚ÇΩ\n`;
                });

                text += `\n‚úÖ –í—Å–µ–≥–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: ${payments.length}\n`;
            }

            // Copy to clipboard
            navigator.clipboard.writeText(text).then(() => {
                // Show success notification
                const exportBtn = document.getElementById('export-messenger');
                const originalText = exportBtn.innerHTML;
                exportBtn.innerHTML = '<i class="fas fa-check"></i> –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
                exportBtn.style.backgroundColor = '#4CAF50';

                setTimeout(() => {
                    exportBtn.innerHTML = originalText;
                    exportBtn.style.backgroundColor = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
            });
        }

        // Event listeners
        addGuestBtn.addEventListener('click', addGuest);
        
        calculateBtn.addEventListener('click', calculatePayments);
        
        clearStorageBtn.addEventListener('click', () => {
            if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ?')) {
                clearStorage();
            }
        });
        
        // Auto-optimize checkbox change
        if (autoOptimizeCheckbox) {
            autoOptimizeCheckbox.addEventListener('change', (e) => {
                partyData.autoOptimize = e.target.checked;
                manualSettingsDiv.style.display = e.target.checked ? 'none' : 'block';
                saveToStorage();
                scheduleRecalculation();
            });
        }

        // Bill strategy change
        for (const radio of billStrategyRadios) {
            radio.addEventListener('change', (e) => {
                partyData.billStrategy = e.target.value;
                saveToStorage();
                scheduleRecalculation();
            });
        }

        // Mode selection change
        for (const radio of modeRadios) {
            radio.addEventListener('change', (e) => {
                partyData.mode = e.target.value;
                updateBudgetKeeperVisibility();
                saveToStorage();
                scheduleRecalculation();
            });
        }

        // Budget keeper selection change
        budgetKeeperSelect.addEventListener('change', (e) => {
            partyData.budgetKeeper = e.target.value ? parseInt(e.target.value) : null;
            saveToStorage();
            scheduleRecalculation();
        });

        // Initialize
        loadFromStorage();

        // Add initial guests if none exist
        if (partyData.guests.length === 0) {
            addGuest();
            addGuest();
        }

        // Initial calculation or placeholder
        autoCalculate();
    </script>
</body>
</html>