<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Object Splitter</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="../../css/common.css">
  <link rel="stylesheet" href="../../css/tool-styles.css">
  <link rel="stylesheet" href="pngsplitter.css">
</head>
<body>
  <div class="container">
    <div class="breadcrumb">
      <a href="../../index.html">Главная</a> &gt;
      <a href="../index.html">Инструменты</a> &gt;
      Image Object Splitter
    </div>
    
    <h1><i class="fas fa-object-ungroup"></i> Image Object Splitter</h1>
    <p class="description">Загрузите изображение и разделите его на отдельные объекты по цвету фона</p>
    
    <div class="controls-container">
      <div class="control-group">
        <label class="control-label">Загрузите изображение</label>
        <div class="file-upload-area" id="dropArea">
          <i class="fas fa-upload"></i>
          <p>Перетащите изображение сюда или нажмите для выбора</p>
          <p class="upload-hint">Также можно вставить изображение из буфера обмена (Ctrl+V)</p>
          <input type="file" accept="image/*" id="fileInput" style="display: none;" multiple>
        </div>
      </div>
      
      <div class="control-group">
        <label class="control-label">Разделяющий цвет</label>
        <div class="color-picker-container">
          <input type="color" id="colorPicker" value="#ffffff">
          <div class="eyedropper-btn" id="eyedropperBtn" title="Выбрать цвет с изображения">
            <i class="fas fa-eye-dropper"></i>
          </div>
        </div>
      </div>
      
      <div class="control-group">
        <label class="control-label">Чувствительность цвета (допуск)</label>
        <div class="tolerance-slider-container">
          <input type="range" id="toleranceSlider" min="0" max="50" value="10" class="tolerance-slider">
          <span id="toleranceValue" class="tolerance-value">10</span>
        </div>
      </div>
    </div>
    
    <div class="preview-container" id="previewContainer">
      <h2>Предпросмотр</h2>
      <img id="previewImage" src="" alt="Предпросмотр изображения">
    </div>
    
    <div class="source-images-container" id="sourceImagesContainer">
      <h2>Загруженные изображения</h2>
      <ul class="source-images-list" id="sourceImagesList">
        <!-- Список загруженных изображений будет добавлен здесь -->
      </ul>
    </div>
    
    <div class="output-container">
      <div class="output-header">
        <h2 class="output-title">Результаты разделения</h2>
        <div class="output-actions" id="outputActions" style="display: none;">
          <button id="downloadAllBtn" class="btn-add"><i class="fas fa-download"></i> Скачать все файлы</button>
          <button id="downloadZipBtn"><i class="fas fa-file-archive"></i> Скачать ZIP</button>
          <button id="clearLastBtn" class="btn-warning"><i class="fas fa-trash-alt"></i> Удалить последние</button>
          <button id="clearAllBtn" class="btn-danger"><i class="fas fa-trash"></i> Очистить все</button>
        </div>
      </div>
      
      <div class="output" id="output">
        <div class="empty-output" id="emptyOutput">
          <i class="fas fa-image"></i>
          <p>Загрузите изображение, чтобы разделить его на объекты</p>
        </div>
      </div>
    </div>
  </div>
  
  <canvas id="mainCanvas"></canvas>
  <canvas id="tempCanvas"></canvas>
  
  <!-- Модальное окно для дополнительного разделения объектов -->
  <div class="modal-overlay" id="subdivisionModal">
    <div class="modal-container">
      <div class="modal-header">
        <h3 class="modal-title">Дополнительное разделение объекта</h3>
        <button class="modal-close" id="closeSubdivisionBtn">&times;</button>
      </div>
      <div class="modal-body">
        <div class="subdivision-container">
          <div class="subdivision-options">
            <button id="autoSubdivideBtn" class="btn-add"><i class="fas fa-magic"></i> Автоматическое разделение</button>
            <button id="manualSubdivideBtn" class="btn-add"><i class="fas fa-pencil-alt"></i> Ручное разделение</button>
          </div>
          
          <div class="subdivision-canvas-container">
            <canvas id="subdivisionCanvas" class="subdivision-canvas"></canvas>
          </div>
          
          <div class="brush-size-container" id="brushSizeContainer" style="display: none;">
            <label>Размер кисти:</label>
            <input type="range" id="brushSizeSlider" min="1" max="20" value="5" class="brush-size-slider">
            <span id="brushSizeValue" class="brush-size-value">5</span>
          </div>
          
          <div class="subdivision-tools">
            <button id="applySubdivisionBtn" class="btn-add"><i class="fas fa-eye"></i> Показать результат</button>
            <button id="saveSubdivisionBtn" class="btn-add" style="display: none;"><i class="fas fa-save"></i> Сохранить разделение</button>
            <button id="resetSubdivisionBtn" class="btn-warning"><i class="fas fa-undo"></i> Сбросить</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  
  <script>
    // Глобальные переменные
    let isEyedropperActive = false;
    let currentTolerance = 10;
    let sourceImages = [];
    let outputObjects = [];
    let lastImageIndex = -1;
    
    // Переменные для дополнительного разделения
    let currentSubdivisionIndex = -1;
    let isDrawingMode = false;
    let currentBrushSize = 5;
    let originalObjectImage = null;
    let subdivisionMasks = [];
    
    // DOM элементы
    const fileInput = document.getElementById('fileInput');
    const dropArea = document.getElementById('dropArea');
    const colorPicker = document.getElementById('colorPicker');
    const eyedropperBtn = document.getElementById('eyedropperBtn');
    const toleranceSlider = document.getElementById('toleranceSlider');
    const toleranceValue = document.getElementById('toleranceValue');
    const previewContainer = document.getElementById('previewContainer');
    const previewImage = document.getElementById('previewImage');
    const sourceImagesContainer = document.getElementById('sourceImagesContainer');
    const sourceImagesList = document.getElementById('sourceImagesList');
    const output = document.getElementById('output');
    const emptyOutput = document.getElementById('emptyOutput');
    const outputActions = document.getElementById('outputActions');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const downloadZipBtn = document.getElementById('downloadZipBtn');
    const clearLastBtn = document.getElementById('clearLastBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const mainCanvas = document.getElementById('mainCanvas');
    const tempCanvas = document.getElementById('tempCanvas');
    
    // DOM элементы для дополнительного разделения
    const subdivisionModal = document.getElementById('subdivisionModal');
    const closeSubdivisionBtn = document.getElementById('closeSubdivisionBtn');
    const autoSubdivideBtn = document.getElementById('autoSubdivideBtn');
    const manualSubdivideBtn = document.getElementById('manualSubdivideBtn');
    const subdivisionCanvas = document.getElementById('subdivisionCanvas');
    const brushSizeContainer = document.getElementById('brushSizeContainer');
    const brushSizeSlider = document.getElementById('brushSizeSlider');
    const brushSizeValue = document.getElementById('brushSizeValue');
    const applySubdivisionBtn = document.getElementById('applySubdivisionBtn');
    const saveSubdivisionBtn = document.getElementById('saveSubdivisionBtn');
    const resetSubdivisionBtn = document.getElementById('resetSubdivisionBtn');
    
    // Функция для проверки совпадения цвета с учетом допуска
    function colorMatch(data, idx, r, g, b, tolerance = currentTolerance) {
      return Math.abs(data[idx] - r) <= tolerance &&
             Math.abs(data[idx + 1] - g) <= tolerance &&
             Math.abs(data[idx + 2] - b) <= tolerance;
    }
    
    // Функция для получения RGB из HEX
    function hexToRgb(hex) {
      const r = parseInt(hex.substr(1, 2), 16);
      const g = parseInt(hex.substr(3, 2), 16);
      const b = parseInt(hex.substr(5, 2), 16);
      return [r, g, b];
    }
    
    // Функция для получения HEX из RGB
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    // Функция для обработки загруженного изображения
    async function processImage(file) {
      if (!file || !file.type.startsWith('image/')) return;
      
      try {
        // Создаем объект изображения
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await img.decode();
        
        // Добавляем изображение в список источников
        const sourceIndex = sourceImages.length;
        sourceImages.push({
          file: file,
          image: img,
          width: img.width,
          height: img.height,
          objectCount: 0
        });
        
        // Обновляем UI
        updateSourceImagesList();
        showPreview(img);
        
        // Обрабатываем изображение
        splitImageObjects(sourceIndex);
      } catch (error) {
        console.error('Ошибка при обработке изображения:', error);
        alert('Ошибка при обработке изображения: ' + error.message);
      }
    }
    
    // Функция для разделения изображения на объекты
    function splitImageObjects(sourceIndex) {
      const sourceImage = sourceImages[sourceIndex];
      const img = sourceImage.image;
      
      // Настраиваем canvas
      mainCanvas.width = img.width;
      mainCanvas.height = img.height;
      const ctx = mainCanvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      // Получаем данные изображения
      const imageData = ctx.getImageData(0, 0, img.width, img.height);
      const data = imageData.data;
      const visited = new Uint8Array(img.width * img.height);
      const objects = [];
      
      // Получаем цвет разделителя
      const [r0, g0, b0] = hexToRgb(colorPicker.value);
      
      // Функция для получения индекса пикселя
      function getIndex(x, y) {
        return y * img.width + x;
      }
      
      // Функция заливки для выделения объекта
      function floodFill(x, y) {
        const queue = [[x, y]];
        const pixels = [];
        let minX = x, maxX = x, minY = y, maxY = y;
        
        while (queue.length) {
          const [cx, cy] = queue.pop();
          const idx = getIndex(cx, cy);
          if (visited[idx]) continue;
          
          const i = idx * 4;
          if (colorMatch(data, i, r0, g0, b0)) continue;
          
          visited[idx] = 1;
          pixels.push([cx, cy]);
          minX = Math.min(minX, cx);
          maxX = Math.max(maxX, cx);
          minY = Math.min(minY, cy);
          maxY = Math.max(maxY, cy);
          
          // Проверяем соседние пиксели (включая диагональные)
          for (const [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]) {
            const nx = cx + dx, ny = cy + dy;
            if (nx >= 0 && ny >= 0 && nx < img.width && ny < img.height) {
              const nidx = getIndex(nx, ny);
              const ni = nidx * 4;
              if (!visited[nidx] && !colorMatch(data, ni, r0, g0, b0)) {
                queue.push([nx, ny]);
              }
            }
          }
        }
        
        return { pixels, bounds: [minX, minY, maxX, maxY] };
      }
      
      // Находим все объекты
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          const idx = getIndex(x, y);
          const i = idx * 4;
          if (!visited[idx] && !colorMatch(data, i, r0, g0, b0)) {
            const obj = floodFill(x, y);
            if (obj.pixels.length > 20) {
              objects.push(obj);
            }
          }
        }
      }
      
      // Обновляем счетчик объектов
      sourceImage.objectCount = objects.length;
      
      // Создаем изображения для каждого объекта
      const newObjects = objects.map((obj, index) => {
        const { bounds } = obj;
        const [minX, minY, maxX, maxY] = bounds;
        const w = maxX - minX + 1;
        const h = maxY - minY + 1;
        
        // Создаем временный canvas для объекта
        tempCanvas.width = w;
        tempCanvas.height = h;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(mainCanvas, minX, minY, w, h, 0, 0, w, h);
        
        // Получаем данные изображения
        const objectDataUrl = tempCanvas.toDataURL('image/png');
        
        return {
          sourceIndex: sourceIndex,
          objectIndex: index,
          width: w,
          height: h,
          dataUrl: objectDataUrl,
          fileName: `object_${sourceIndex}_${index}.png`
        };
      });
      
      // Добавляем новые объекты в общий список
      outputObjects = [...outputObjects, ...newObjects];
      lastImageIndex = sourceIndex;
      
      // Обновляем UI
      updateOutputDisplay();
      updateSourceImagesList();
    }
    
    // Функция для обновления списка исходных изображений
    function updateSourceImagesList() {
      if (sourceImages.length === 0) {
        sourceImagesContainer.style.display = 'none';
        return;
      }
      
      sourceImagesContainer.style.display = 'block';
      sourceImagesList.innerHTML = '';
      
      sourceImages.forEach((source, index) => {
        const li = document.createElement('li');
        li.className = 'source-image-item';
        
        const img = document.createElement('img');
        img.className = 'source-image-preview';
        img.src = URL.createObjectURL(source.file);
        img.alt = source.file.name;
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'source-image-info';
        
        const nameDiv = document.createElement('div');
        nameDiv.className = 'source-image-name';
        nameDiv.textContent = source.file.name;
        
        const metaDiv = document.createElement('div');
        metaDiv.className = 'source-image-meta';
        metaDiv.textContent = `${source.width}x${source.height} | Объектов: ${source.objectCount}`;
        
        infoDiv.appendChild(nameDiv);
        infoDiv.appendChild(metaDiv);
        
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'source-image-actions';
        
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'btn-add';
        downloadBtn.innerHTML = '<i class="fas fa-download"></i> Скачать объекты';
        downloadBtn.addEventListener('click', () => downloadSourceObjects(index));
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn-danger';
        removeBtn.innerHTML = '<i class="fas fa-trash"></i> Удалить';
        removeBtn.addEventListener('click', () => removeSourceImage(index));
        
        actionsDiv.appendChild(downloadBtn);
        actionsDiv.appendChild(removeBtn);
        
        li.appendChild(img);
        li.appendChild(infoDiv);
        li.appendChild(actionsDiv);
        
        sourceImagesList.appendChild(li);
      });
    }
    
    // Функция для обновления отображения результатов
    function updateOutputDisplay() {
      if (outputObjects.length === 0) {
        output.innerHTML = '';
        output.appendChild(emptyOutput);
        outputActions.style.display = 'none';
        return;
      }
      
      output.innerHTML = '';
      outputActions.style.display = 'flex';
      
      outputObjects.forEach((obj, index) => {
        const div = document.createElement('div');
        div.className = 'output-item';
        div.dataset.index = index;
        
        const img = document.createElement('img');
        img.src = obj.dataUrl;
        img.alt = `Object ${index}`;
        
        const overlay = document.createElement('div');
        overlay.className = 'output-item-overlay';
        overlay.textContent = `${obj.width}x${obj.height}`;
        
        const actions = document.createElement('div');
        actions.className = 'output-item-actions';
        
        const downloadBtn = document.createElement('button');
        downloadBtn.innerHTML = '<i class="fas fa-download"></i>';
        downloadBtn.title = 'Скачать';
        downloadBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          downloadObject(index);
        });
        
        const splitBtn = document.createElement('button');
        splitBtn.innerHTML = '<i class="fas fa-cut"></i>';
        splitBtn.title = 'Разделить дальше';
        splitBtn.className = 'split-btn';
        splitBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          openSubdivisionModal(index);
        });
        
        actions.appendChild(downloadBtn);
        actions.appendChild(splitBtn);
        
        div.appendChild(img);
        div.appendChild(overlay);
        div.appendChild(actions);
        
        output.appendChild(div);
      });
    }
    
    // Функция для показа предпросмотра
    function showPreview(img) {
      previewImage.src = img.src;
      previewContainer.style.display = 'block';
      
      // Настраиваем пипетку
      previewImage.addEventListener('click', function(e) {
        if (!isEyedropperActive) return;
        
        const rect = previewImage.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width * img.width;
        const y = (e.clientY - rect.top) / rect.height * img.height;
        
        // Получаем цвет пикселя
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        const pixel = ctx.getImageData(x, y, 1, 1).data;
        const [r, g, b] = [pixel[0], pixel[1], pixel[2]];
        const hex = rgbToHex(r, g, b);
        
        // Устанавливаем цвет в пикер
        colorPicker.value = hex;
        
        // Деактивируем пипетку
        isEyedropperActive = false;
        eyedropperBtn.classList.remove('active');
      });
    }
    
    // Функция для скачивания одного объекта
    function downloadObject(index) {
      const obj = outputObjects[index];
      const link = document.createElement('a');
      link.href = obj.dataUrl;
      link.download = obj.fileName;
      link.click();
    }
    
    // Функция для скачивания всех объектов одного изображения
    function downloadSourceObjects(sourceIndex) {
      const objects = outputObjects.filter(obj => obj.sourceIndex === sourceIndex);
      objects.forEach(obj => {
        const link = document.createElement('a');
        link.href = obj.dataUrl;
        link.download = obj.fileName;
        setTimeout(() => link.click(), 100 * obj.objectIndex);
      });
    }
    
    // Функция для скачивания всех объектов
    function downloadAllObjects() {
      outputObjects.forEach((obj, index) => {
        const link = document.createElement('a');
        link.href = obj.dataUrl;
        link.download = obj.fileName;
        setTimeout(() => link.click(), 100 * index);
      });
    }
    
    // Функция для скачивания ZIP-архива
    async function downloadZip() {
      const zip = new JSZip();
      
      // Добавляем все объекты в архив
      for (let i = 0; i < outputObjects.length; i++) {
        const obj = outputObjects[i];
        
        // Конвертируем dataUrl в blob
        const response = await fetch(obj.dataUrl);
        const blob = await response.blob();
        
        // Добавляем в архив
        zip.file(obj.fileName, blob);
      }
      
      // Генерируем архив и скачиваем
      zip.generateAsync({type: 'blob'}).then(function(content) {
        saveAs(content, 'png_objects.zip');
      });
    }
    
    // Функция для удаления исходного изображения и его объектов
    function removeSourceImage(index) {
      // Удаляем объекты этого изображения
      outputObjects = outputObjects.filter(obj => obj.sourceIndex !== index);
      
      // Обновляем индексы для оставшихся объектов
      outputObjects = outputObjects.map(obj => {
        if (obj.sourceIndex > index) {
          return {...obj, sourceIndex: obj.sourceIndex - 1};
        }
        return obj;
      });
      
      // Удаляем изображение из списка
      sourceImages.splice(index, 1);
      
      // Обновляем lastImageIndex
      if (lastImageIndex === index) {
        lastImageIndex = sourceImages.length - 1;
      } else if (lastImageIndex > index) {
        lastImageIndex--;
      }
      
      // Обновляем UI
      updateSourceImagesList();
      updateOutputDisplay();
    }
    
    // Функция для удаления результатов последней загруженной картинки
    function clearLastResults() {
      if (lastImageIndex === -1) return;
      
      // Удаляем объекты последнего изображения
      outputObjects = outputObjects.filter(obj => obj.sourceIndex !== lastImageIndex);
      
      // Обновляем счетчик объектов
      if (sourceImages[lastImageIndex]) {
        sourceImages[lastImageIndex].objectCount = 0;
      }
      
      // Обновляем UI
      updateSourceImagesList();
      updateOutputDisplay();
    }
    
    // Функция для очистки всех результатов
    function clearAllResults() {
      outputObjects = [];
      
      // Обновляем счетчики объектов
      sourceImages.forEach(source => {
        source.objectCount = 0;
      });
      
      // Обновляем UI
      updateSourceImagesList();
      updateOutputDisplay();
    }
    
    // Функции для дополнительного разделения объектов
    
    // Открытие модального окна для дополнительного разделения
    function openSubdivisionModal(index) {
      currentSubdivisionIndex = index;
      const obj = outputObjects[index];
      
      // Загружаем изображение объекта
      const img = new Image();
      img.src = obj.dataUrl;
      img.onload = function() {
        // Сохраняем оригинальное изображение
        originalObjectImage = img;
        
        // Настраиваем canvas
        subdivisionCanvas.width = img.width;
        subdivisionCanvas.height = img.height;
        const ctx = subdivisionCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        // Сбрасываем режим рисования
        isDrawingMode = false;
        brushSizeContainer.style.display = 'none';
        
        // Показываем модальное окно
        subdivisionModal.classList.add('active');
      };
    }
    
    // Закрытие модального окна
    function closeSubdivisionModal() {
      subdivisionModal.classList.remove('active');
      currentSubdivisionIndex = -1;
      originalObjectImage = null;
      subdivisionMasks = [];
      
      // Скрываем кнопку сохранения
      saveSubdivisionBtn.style.display = 'none';
    }
    
    // Автоматическое разделение объекта
    function autoSubdivide() {
      if (!originalObjectImage) return;
      
      const width = originalObjectImage.width;
      const height = originalObjectImage.height;
      
      // Настраиваем canvas
      subdivisionCanvas.width = width;
      subdivisionCanvas.height = height;
      const ctx = subdivisionCanvas.getContext('2d');
      ctx.drawImage(originalObjectImage, 0, 0);
      
      // Получаем данные изображения
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      // Получаем цвет разделителя
      const [r0, g0, b0] = hexToRgb(colorPicker.value);
      
      // Создаем копию данных для работы
      const tempData = new Uint8ClampedArray(data);
      
      // Функция для получения индекса пикселя
      function getIndex(x, y) {
        return (y * width + x) * 4;
      }
      
      // Функция для проверки, является ли пиксель граничным
      function isBorderPixel(x, y) {
        // Проверяем, касается ли пиксель края изображения
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          return true;
        }
        
        // Проверяем, касается ли пиксель фонового цвета
        for (const [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
            const nidx = getIndex(nx, ny);
            if (colorMatch(tempData, nidx, r0, g0, b0)) {
              return true;
            }
          }
        }
        
        return false;
      }
      
      // Функция для закрашивания граничных пикселей
      function eraseBorderPixels() {
        let changed = false;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = getIndex(x, y);
            
            // Пропускаем пиксели фона
            if (colorMatch(tempData, idx, r0, g0, b0)) {
              continue;
            }
            
            // Если пиксель граничный, закрашиваем его в цвет фона
            if (isBorderPixel(x, y)) {
              tempData[idx] = r0;
              tempData[idx + 1] = g0;
              tempData[idx + 2] = b0;
              tempData[idx + 3] = 255;
              changed = true;
            }
          }
        }
        
        return changed;
      }
      
      // Функция для поиска компонент связности
      function findConnectedComponents() {
        const visited = new Uint8Array(width * height);
        const components = [];
        
        // Функция для получения индекса в массиве visited
        function getVisitedIndex(x, y) {
          return y * width + x;
        }
        
        // Функция заливки для выделения компоненты
        function floodFill(x, y) {
          const queue = [[x, y]];
          const pixels = [];
          
          while (queue.length) {
            const [cx, cy] = queue.pop();
            const vidx = getVisitedIndex(cx, cy);
            if (visited[vidx]) continue;
            
            const idx = getIndex(cx, cy);
            if (colorMatch(tempData, idx, r0, g0, b0)) continue;
            
            visited[vidx] = 1;
            pixels.push([cx, cy]);
            
            // Проверяем соседние пиксели
            for (const [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
              const nx = cx + dx, ny = cy + dy;
              if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                const nvidx = getVisitedIndex(nx, ny);
                const nidx = getIndex(nx, ny);
                if (!visited[nvidx] && !colorMatch(tempData, nidx, r0, g0, b0)) {
                  queue.push([nx, ny]);
                }
              }
            }
          }
          
          return pixels;
        }
        
        // Находим все компоненты
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const vidx = getVisitedIndex(x, y);
            const idx = getIndex(x, y);
            if (!visited[vidx] && !colorMatch(tempData, idx, r0, g0, b0)) {
              const component = floodFill(x, y);
              if (component.length > 20) {  // Игнорируем слишком маленькие компоненты
                components.push(component);
              }
            }
          }
        }
        
        return components;
      }
      
      // Функция для создания масок компонент
      function createComponentMasks(components) {
        const masks = [];
        
        for (const component of components) {
          const mask = new Uint8Array(width * height);
          
          // Заполняем маску
          for (const [x, y] of component) {
            const idx = y * width + x;
            mask[idx] = 1;
          }
          
          masks.push(mask);
        }
        
        return masks;
      }
      
      // Функция для расширения масок
      function growMasks(masks) {
        const tempMasks = masks.map(mask => new Uint8Array(mask));
        let changed = true;
        
        while (changed) {
          changed = false;
          
          for (let m = 0; m < masks.length; m++) {
            const mask = masks[m];
            
            for (let y = 0; y < height; y++) {
              for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                
                // Пропускаем уже замаскированные пиксели
                if (mask[idx]) continue;
                
                // Пропускаем пиксели фона
                const dataIdx = getIndex(x, y);
                if (colorMatch(data, dataIdx, r0, g0, b0)) continue;
                
                // Проверяем, есть ли соседние пиксели в этой маске
                let hasNeighbor = false;
                for (const [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
                  const nx = x + dx, ny = y + dy;
                  if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                    const nidx = ny * width + nx;
                    if (mask[nidx]) {
                      hasNeighbor = true;
                      break;
                    }
                  }
                }
                
                // Если есть сосед в этой маске и пиксель не замаскирован другими масками
                if (hasNeighbor) {
                  let isFree = true;
                  for (let om = 0; om < masks.length; om++) {
                    if (om !== m && masks[om][idx]) {
                      isFree = false;
                      break;
                    }
                  }
                  
                  if (isFree) {
                    tempMasks[m][idx] = 1;
                    changed = true;
                  }
                }
              }
            }
          }
          
          // Копируем временные маски обратно
          for (let m = 0; m < masks.length; m++) {
            masks[m] = new Uint8Array(tempMasks[m]);
          }
        }
        
        return masks;
      }
      
      // Выполняем автоматическое разделение
      let iterations = 0;
      let components;
      
      // Повторяем стирание граничных пикселей, пока не получим несколько компонент
      // или не достигнем максимального числа итераций
      do {
        eraseBorderPixels();
        components = findConnectedComponents();
        iterations++;
      } while (components.length < 2 && iterations < 20);
      
      // Если нашли несколько компонент
      if (components.length >= 2) {
        // Создаем маски компонент
        let masks = createComponentMasks(components);
        
        // Расширяем маски
        masks = growMasks(masks);
        
        // Сохраняем маски
        subdivisionMasks = masks;
        
        // Отображаем результат
        displaySubdivisionResult();
      } else {
        alert('Не удалось автоматически разделить объект. Попробуйте ручное разделение.');
      }
    }
    
    // Включение режима ручного разделения
    function enableManualSubdivide() {
      if (!originalObjectImage) return;
      
      isDrawingMode = true;
      brushSizeContainer.style.display = 'flex';
      
      // Настраиваем canvas
      const width = originalObjectImage.width;
      const height = originalObjectImage.height;
      subdivisionCanvas.width = width;
      subdivisionCanvas.height = height;
      const ctx = subdivisionCanvas.getContext('2d');
      ctx.drawImage(originalObjectImage, 0, 0);
      
      // Получаем цвет разделителя
      const [r0, g0, b0] = hexToRgb(colorPicker.value);
      
      // Переменные для рисования
      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;
      
      // Функция для рисования линии
      function drawLine(x1, y1, x2, y2) {
        const ctx = subdivisionCanvas.getContext('2d');
        ctx.beginPath();
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = currentBrushSize;
        ctx.lineCap = 'round';
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      
      // Обработчики событий для рисования
      subdivisionCanvas.addEventListener('mousedown', function(e) {
        if (!isDrawingMode) return;
        
        isDrawing = true;
        const rect = subdivisionCanvas.getBoundingClientRect();
        lastX = (e.clientX - rect.left) / (rect.width / width);
        lastY = (e.clientY - rect.top) / (rect.height / height);
      });
      
      subdivisionCanvas.addEventListener('mousemove', function(e) {
        if (!isDrawingMode || !isDrawing) return;
        
        const rect = subdivisionCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / (rect.width / width);
        const y = (e.clientY - rect.top) / (rect.height / height);
        
        drawLine(lastX, lastY, x, y);
        
        lastX = x;
        lastY = y;
      });
      
      subdivisionCanvas.addEventListener('mouseup', function() {
        isDrawing = false;
      });
      
      subdivisionCanvas.addEventListener('mouseleave', function() {
        isDrawing = false;
      });
    }
    
    // Применение ручного разделения
    function applyManualSubdivide() {
      if (!originalObjectImage || !isDrawingMode) return;
      
      const width = originalObjectImage.width;
      const height = originalObjectImage.height;
      
      // Получаем данные с canvas
      const ctx = subdivisionCanvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      // Получаем цвет разделителя
      const [r0, g0, b0] = hexToRgb(colorPicker.value);
      
      // Функция для получения индекса пикселя
      function getIndex(x, y) {
        return (y * width + x) * 4;
      }
      
      // Функция для поиска компонент связности
      function findConnectedComponents() {
        const visited = new Uint8Array(width * height);
        const components = [];
        
        // Функция для получения индекса в массиве visited
        function getVisitedIndex(x, y) {
          return y * width + x;
        }
        
        // Функция заливки для выделения компоненты
        function floodFill(x, y) {
          const queue = [[x, y]];
          const pixels = [];
          
          while (queue.length) {
            const [cx, cy] = queue.pop();
            const vidx = getVisitedIndex(cx, cy);
            if (visited[vidx]) continue;
            
            const idx = getIndex(cx, cy);
            if (colorMatch(data, idx, r0, g0, b0)) continue;
            
            visited[vidx] = 1;
            pixels.push([cx, cy]);
            
            // Проверяем соседние пиксели
            for (const [dx, dy] of [[1,0], [-1,0], [0,1], [0,-1]]) {
              const nx = cx + dx, ny = cy + dy;
              if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                const nvidx = getVisitedIndex(nx, ny);
                const nidx = getIndex(nx, ny);
                if (!visited[nvidx] && !colorMatch(data, nidx, r0, g0, b0)) {
                  queue.push([nx, ny]);
                }
              }
            }
          }
          
          return pixels;
        }
        
        // Находим все компоненты
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const vidx = getVisitedIndex(x, y);
            const idx = getIndex(x, y);
            if (!visited[vidx] && !colorMatch(data, idx, r0, g0, b0)) {
              const component = floodFill(x, y);
              if (component.length > 20) {  // Игнорируем слишком маленькие компоненты
                components.push(component);
              }
            }
          }
        }
        
        return components;
      }
      
      // Функция для создания масок компонент
      function createComponentMasks(components) {
        const masks = [];
        
        for (const component of components) {
          const mask = new Uint8Array(width * height);
          
          // Заполняем маску
          for (const [x, y] of component) {
            const idx = y * width + x;
            mask[idx] = 1;
          }
          
          masks.push(mask);
        }
        
        return masks;
      }
      
      // Находим компоненты
      const components = findConnectedComponents();
      
      // Если нашли несколько компонент
      if (components.length >= 2) {
        // Создаем маски компонент
        subdivisionMasks = createComponentMasks(components);
        
        // Отображаем результат
        displaySubdivisionResult();
      } else {
        alert('Не удалось разделить объект. Попробуйте нарисовать более четкую линию разделения.');
      }
    }
    
    // Отображение результата разделения
    function displaySubdivisionResult() {
      if (!originalObjectImage || subdivisionMasks.length < 2) return;
      
      const width = originalObjectImage.width;
      const height = originalObjectImage.height;
      
      // Настраиваем canvas
      subdivisionCanvas.width = width;
      subdivisionCanvas.height = height;
      const ctx = subdivisionCanvas.getContext('2d');
      
      // Рисуем оригинальное изображение
      ctx.drawImage(originalObjectImage, 0, 0);
      
      // Получаем данные изображения
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;
      
      // Функция для обрезки холста до размеров фактического содержимого
      function trimCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
        
        // Находим границы непрозрачного содержимого
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const idx = (y * canvas.width + x) * 4;
            if (data[idx + 3] > 0) { // Если пиксель не прозрачный
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            }
          }
        }
        
        // Если изображение полностью прозрачное, возвращаем исходный холст
        if (minX > maxX || minY > maxY) {
          return canvas;
        }
        
        // Создаем новый холст с обрезанными размерами
        const trimmedCanvas = document.createElement('canvas');
        const trimmedWidth = maxX - minX + 1;
        const trimmedHeight = maxY - minY + 1;
        trimmedCanvas.width = trimmedWidth;
        trimmedCanvas.height = trimmedHeight;
        
        // Копируем только непрозрачную часть
        const trimmedCtx = trimmedCanvas.getContext('2d');
        trimmedCtx.drawImage(canvas, minX, minY, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);
        
        return trimmedCanvas;
      }
      
      // Создаем временный canvas для каждой маски
      const tempCanvases = subdivisionMasks.map((mask, index) => {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const tempCtx = canvas.getContext('2d');
        
        // Создаем новые данные изображения
        const newImageData = new ImageData(width, height);
        const newData = newImageData.data;
        
        // Копируем пиксели из оригинального изображения согласно маске
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const maskIdx = y * width + x;
            
            if (mask[maskIdx]) {
              newData[idx] = data[idx];
              newData[idx + 1] = data[idx + 1];
              newData[idx + 2] = data[idx + 2];
              newData[idx + 3] = data[idx + 3];
            } else {
              newData[idx + 3] = 0;  // Прозрачный пиксель
            }
          }
        }
        
        // Рисуем на временном canvas
        tempCtx.putImageData(newImageData, 0, 0);
        
        // Обрезаем холст до размеров фактического содержимого
        return trimCanvas(canvas);
      });
      
      // Очищаем canvas
      ctx.clearRect(0, 0, width, height);
      
      // Рисуем каждую компоненту с разным оттенком для визуализации
      const colors = ['rgba(255,0,0,0.3)', 'rgba(0,255,0,0.3)', 'rgba(0,0,255,0.3)', 'rgba(255,255,0,0.3)'];
      
      // Сначала рисуем оригинальное изображение
      ctx.drawImage(originalObjectImage, 0, 0);
      
      // Затем рисуем полупрозрачные цветные области для каждой маски
      subdivisionMasks.forEach((mask, index) => {
        const color = colors[index % colors.length];
        ctx.fillStyle = color;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const maskIdx = y * width + x;
            
            if (mask[maskIdx]) {
              ctx.fillRect(x, y, 1, 1);
            }
          }
        }
      });
      
      // Сохраняем временные canvas для использования при применении разделения
      subdivisionMasks.tempCanvases = tempCanvases;
    }
    
    // Применение разделения
    function applySubdivision() {
      if (!originalObjectImage || subdivisionMasks.length < 2 || currentSubdivisionIndex === -1) return;
      
      // Получаем текущий объект
      const obj = outputObjects[currentSubdivisionIndex];
      
      // Удаляем текущий объект из списка
      outputObjects.splice(currentSubdivisionIndex, 1);
      
      // Добавляем новые объекты
      const newObjects = subdivisionMasks.tempCanvases.map((canvas, index) => {
        const dataUrl = canvas.toDataURL('image/png');
        
        return {
          sourceIndex: obj.sourceIndex,
          objectIndex: obj.objectIndex + '_sub' + index,
          width: canvas.width,
          height: canvas.height,
          dataUrl: dataUrl,
          fileName: `object_${obj.sourceIndex}_${obj.objectIndex}_sub${index}.png`
        };
      });
      
      // Добавляем новые объекты в общий список
      outputObjects = [...outputObjects, ...newObjects];
      
      // Обновляем счетчик объектов
      if (sourceImages[obj.sourceIndex]) {
        sourceImages[obj.sourceIndex].objectCount += newObjects.length - 1;
      }
      
      // Обновляем UI
      updateOutputDisplay();
      updateSourceImagesList();
      
      // Скрываем кнопку сохранения
      saveSubdivisionBtn.style.display = 'none';
      
      // Закрываем модальное окно
      closeSubdivisionModal();
    }
    
    // Сброс разделения
    function resetSubdivision() {
      if (!originalObjectImage) return;
      
      // Сбрасываем маски
      subdivisionMasks = [];
      
      // Настраиваем canvas
      subdivisionCanvas.width = originalObjectImage.width;
      subdivisionCanvas.height = originalObjectImage.height;
      const ctx = subdivisionCanvas.getContext('2d');
      ctx.drawImage(originalObjectImage, 0, 0);
      
      // Если в режиме рисования, оставляем его активным
      if (isDrawingMode) {
        brushSizeContainer.style.display = 'flex';
      } else {
        brushSizeContainer.style.display = 'none';
      }
      
      // Скрываем кнопку сохранения
      saveSubdivisionBtn.style.display = 'none';
    }
    
    // Обработчики событий
    
    // Загрузка файлов через input
    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      files.forEach(file => processImage(file));
    });
    
    // Drag and drop
    dropArea.addEventListener('click', () => fileInput.click());
    
    dropArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropArea.classList.add('drag-over');
    });
    
    dropArea.addEventListener('dragleave', () => {
      dropArea.classList.remove('drag-over');
    });
    
    dropArea.addEventListener('drop', (e) => {
      e.preventDefault();
      dropArea.classList.remove('drag-over');
      
      const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
      files.forEach(file => processImage(file));
    });
    
    // Вставка из буфера обмена
    document.addEventListener('paste', (e) => {
      const items = (e.clipboardData || e.originalEvent.clipboardData).items;
      
      for (const item of items) {
        if (item.type.indexOf('image') === 0) {
          const file = item.getAsFile();
          processImage(file);
          break;
        }
      }
    });
    
    // Изменение цвета
    colorPicker.addEventListener('change', () => {
      // Если есть загруженные изображения, пересчитываем объекты
      if (lastImageIndex !== -1) {
        clearAllResults();
        sourceImages.forEach((_, index) => splitImageObjects(index));
      }
    });
    
    // Пипетка
    eyedropperBtn.addEventListener('click', () => {
      isEyedropperActive = !isEyedropperActive;
      eyedropperBtn.classList.toggle('active', isEyedropperActive);
    });
    
    // Изменение допуска
    toleranceSlider.addEventListener('input', (e) => {
      currentTolerance = parseInt(e.target.value);
      toleranceValue.textContent = currentTolerance;
      
      // Если есть загруженные изображения, пересчитываем объекты
      if (lastImageIndex !== -1) {
        clearAllResults();
        sourceImages.forEach((_, index) => splitImageObjects(index));
      }
    });
    
    // Кнопки действий
    downloadAllBtn.addEventListener('click', downloadAllObjects);
    downloadZipBtn.addEventListener('click', downloadZip);
    clearLastBtn.addEventListener('click', clearLastResults);
    clearAllBtn.addEventListener('click', clearAllResults);
    
    // Обработчики событий для дополнительного разделения
    document.getElementById('closeSubdivisionBtn').addEventListener('click', closeSubdivisionModal);
    
    autoSubdivideBtn.addEventListener('click', () => {
      autoSubdivide();
    });
    
    manualSubdivideBtn.addEventListener('click', () => {
      enableManualSubdivide();
    });
    
    applySubdivisionBtn.addEventListener('click', () => {
      if (isDrawingMode) {
        applyManualSubdivide();
      } else {
        autoSubdivide();
      }
      
      // Если успешно разделили объект (есть маски), показываем кнопку сохранения
      if (subdivisionMasks.length >= 2) {
        saveSubdivisionBtn.style.display = 'inline-block';
      }
    });
    
    saveSubdivisionBtn.addEventListener('click', () => {
      applySubdivision();
    });
    
    resetSubdivisionBtn.addEventListener('click', resetSubdivision);
    
    brushSizeSlider.addEventListener('input', (e) => {
      currentBrushSize = parseInt(e.target.value);
      brushSizeValue.textContent = currentBrushSize;
    });
  </script>
</body>
</html>
